---
layout: project
title: Torrent Report
date: May 15
tech:
  - node
  - postgres
  - redis
  - styled-components
images:
  - ./1.png
  - ./2.png
  - ./3.png
  - ./4.png
  - ./5.png
  - ./6.png
  - ./7.png
---

import { Box, Heading, Text } from 'rebass'

Now we'reghadhaskjhdkgjhasdjkghasjhkas

```js
const { createFilePath } = require('gatsby-source-filesystem')
const path = require('path')

exports.onCreateNode = ({ node, actions, getNode }) => {
  const { createNodeField } = actions
  switch (node.internal.type) {
    case 'Mdx':
    case 'MarkdownRemark':
      {
        const value = createFilePath({ node, getNode })
        const { permalink } = node.frontmatter
        let slug = permalink ? `/${permalink}/` : undefined
        if (!slug) {
          const isPage = node.fileAbsolutePath.indexOf('/src/content/pages/')
          if (isPage >= 0) {
            slug = value
          } else {
            const noncontent = node.fileAbsolutePath.indexOf('/src/content/')
            const { length } = '/src/content/'
            const full = path.parse(node.fileAbsolutePath.slice(noncontent + length))
            slug = `/${full.dir}/${full.name}/`
          }
        }
        createNodeField({
          name: 'slug',
          node,
          value: slug || ''
        })
        const type = node.fileAbsolutePath.match(/src\/content\/(.*)\//)
        createNodeField({
          name: 'type',
          node,
          value: type[1] || ''
        })
      }
      break
    default:
      break
  }
}

exports.createPages = async ({ graphql, actions, reporter }) => {
  const { createPage } = actions

  const ProjectTemplate = require.resolve('./src/templates/project.tsx')
  const PageTemplate = require.resolve('./src/templates/page.tsx')

  const allMarkdownQuery = await graphql(`
    {
      allMarkdown: allMdx(sort: { fields: [frontmatter___date], order: DESC }, limit: 1000) {
        edges {
          node {
            fields {
              slug
            }
            fileAbsolutePath
            frontmatter {
              title
            }
          }
        }
      }
    }
  `)

  if (allMarkdownQuery.errors) {
    reporter.panic(allMarkdownQuery.errors)
  }

  // const postPerPageQuery = await graphql(`
  //   {
  //     site {
  //       siteMetadata {
  //         postsPerPage
  //       }
  //     }
  //   }
  // `)

  const markdownFiles = allMarkdownQuery.data.allMarkdown.edges

  const projects = markdownFiles.filter(item => item.node.fileAbsolutePath.includes('/content/projects/'))
  // console.log('projectsprojectsprojectsprojectsprojectsprojectsprojectsprojectsprojectsprojects', projects) // generate paginated post list
  // const postsPerPage = postPerPageQuery.data.site.siteMetadata.postsPerPage
  // const nbPages = Math.ceil(posts.length / postsPerPage)

  // Array.from({ length: nbPages }).forEach((_, i) => {
  //   createPage({
  //     path: i === 0 ? `/` : `/pages/${i + 1}`,
  //     component: ListPostsTemplate,
  //     context: {
  //       limit: postsPerPage,
  //       skip: i * postsPerPage,
  //       currentPage: i + 1,
  //       nbPages: nbPages,
  //     },
  //   })
  // })

  // generate projects pages
  projects.forEach((post, index, posts) => {
    // const previous = index === posts.length - 1 ? null : posts[index + 1].node
    // const next = index === 0 ? null : posts[index - 1].node

    createPage({
      path: post.node.fields.slug,
      component: ProjectTemplate,
      context: {
        slug: post.node.fields.slug
        // previous,
        // next
      }
    })

    // generate post share images (dev only)
    // if (process.env.gatsby_executing_command.includes('develop')) {
    //   createPage({
    //     path: `${post.node.frontmatter.slug}/image_share`,
    //     component: BlogPostShareImage,
    //     context: {
    //       slug: post.node.frontmatter.slug,
    //       width: 440,
    //       height: 220,
    //     },
    //   })
    // }
  })

  // generate pages
  markdownFiles
    .filter(item => item.node.fileAbsolutePath.includes('/content/pages/'))
    .forEach(page => {
      createPage({
        path: page.node.fields.slug,
        component: PageTemplate,
        context: {
          slug: page.node.fields.slug
        }
      })
    })

  // generate tags
  // markdownFiles
  //   .filter(item => item.node.frontmatter.tags !== null)
  //   .reduce(
  //     (acc, cur) => [...new Set([...acc, ...cur.node.frontmatter.tags])],
  //     []
  //   )
  //   .forEach(uniqTag => {
  //     createPage({
  //       path: `tags/${uniqTag}`,
  //       component: PostsBytagTemplate,
  //       context: {
  //         tag: uniqTag,
  //       },
  //     })
  //   })
}

```

<Box>
  <Heading ml="4">Here's a JSX block</Heading>
  <Text color="red">It's pretty neat</Text>
</Box>

This starter has out-of-the-box support for basic Markdown rendering. The `content/` directory is where you put all of your Markdown content in. Gatsby will build your pages out of it. Gatsby will also follow the directory structure of your files too,dsdjfksjdhfkjsdhfkjhsdkfjhsd so when you store a page at e.g. `content/projects/large-hadron-collider.md`, it will be built in `/projects/large-hadron-collider/`.

```jsx

/** @jsx jsx */
import { jsx } from 'theme-ui'
import { Link } from 'gatsby'

export default props => (
  <Link
    {...props}
    partiallyActive
    activeClassName="active"
    sx={{
      variant: 'links.nav'
    }}
  />
)


```

[That's cool! Okay, take me back home.](/)
